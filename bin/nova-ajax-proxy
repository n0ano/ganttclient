#!/usr/bin/python

import os
import sys
import time

# If ../nova/__init__.py exists, add ../ to Python search path, so that
# it will override what happens to be installed in /usr/(local/)lib/python...
possible_topdir = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                   os.pardir,
                                   os.pardir))
if os.path.exists(os.path.join(possible_topdir, 'nova', '__init__.py')):
    sys.path.insert(0, possible_topdir)

from nova import exception
from nova import flags
from nova import utils
from nova import rpc

import exceptions
import logging
import urlparse

FLAGS = flags.FLAGS
from twisted.internet import reactor
from twisted.internet import task
from twisted.web import error, http
from twisted.web.proxy import Proxy, ProxyRequest

flags.DEFINE_integer('ajax_console_idle_timeout', 300, 
                     'Seconds before idle connection destroyed')
 
class AjaxConsoleProxyRequest(ProxyRequest):
    def process(self):
        if 'referer' in self.received_headers:
            auth_uri = self.received_headers['referer']
        else:
            auth_uri = self.uri

        try:
            auth_params = urlparse.parse_qs(urlparse.urlparse(auth_uri).query)
            parsed_uri = urlparse.urlparse(self.uri)

            auth_info = auth_params['token'][0]
            auth_info  = AjaxConsoleProxy.tokens[auth_params['token'][0]]
            args = auth_info['args'] 
            auth_info['last_activity_at'] = time.time() 

            
            self.uri = ("http://%s:%s%s?token=%s"% (
                        str(args['host']),
                        str(args['port']),
                        parsed_uri.path,
                        str(args['token'])))

            ProxyRequest.process(self)
        except (exceptions.KeyError):
            raise exception.NotAuthorized("Unauthorized Request")

class AjaxConsoleProxy(Proxy):
    #tokens = {}
    tokens = {'key': {'args':'','last_activity_at':time.time()}}
    requestFactory = AjaxConsoleProxyRequest

    def start(self):
        conn = rpc.Connection.instance(new=True)
        self.consumer = rpc.TopicConsumer(
                        connection=conn,
                        topic=FLAGS.ajax_console_proxy_topic)
        self.consumer.register_callback(self)

        task.LoopingCall(self.age).start(1.0)
        task.LoopingCall(self.pollq).start(0.1)

        factory = http.HTTPFactory()
        factory.protocol = AjaxConsoleProxy
         
        port = urlparse.urlparse(FLAGS.ajax_console_proxy_url).port
        reactor.listenTCP(port, factory)
        reactor.run()

    def age(self):
        now = time.time()
        print now
        to_delete = []
        for k, v in AjaxConsoleProxy.tokens.items():
            if now - v['last_activity_at'] > FLAGS.ajax_console_idle_timeout:
                to_delete.append(k)

        for k in to_delete:
            print "del"
            del AjaxConsoleProxy.tokens[k]

    def pollq(self):
        self.consumer.fetch(auto_ack=True, enable_callbacks=True)
 
    def __call__(self, data, message):
        if data['method'] == 'authorize_ajax_console':
            AjaxConsoleProxy.tokens[data['args']['token']] = {'args': data['args'], 'born_at': time.time()}


if __name__ == '__main__':
    utils.default_flagfile()
    FLAGS(sys.argv)

    formatter = logging.Formatter('(%(name)s): %(levelname)s %(message)s')
    handler = logging.StreamHandler()
    handler.setFormatter(formatter)
    logging.getLogger().addHandler(handler)

    ajaxproxy = AjaxConsoleProxy()
    ajaxproxy.start()
     
